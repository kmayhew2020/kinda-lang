"""
Security Tests for Issue #109: Arbitrary File Access and Code Execution Vulnerability

These tests verify that the security sandboxing solution prevents the critical
vulnerability described in Issue #109 while maintaining kinda-lang functionality.

Test Coverage:
- File system access controls
- Path traversal prevention
- System file protection
- Code execution restrictions
- Security level enforcement
"""

import pytest
import tempfile
import os
import sys
from pathlib import Path
from unittest.mock import patch, mock_open

from kinda.security.execution import SecureExecutionEngine, SecurityLevel, ExecutionResult
from kinda.security.filesystem import FileSystemSandbox, FileAccessError
from kinda.security.sandbox import PythonSandbox


class TestIssue109FileAccessVulnerability:
    """Test prevention of arbitrary file access (Issue #109 core vulnerability)"""

    def setup_method(self):
        self.engine = SecureExecutionEngine(SecurityLevel.SAFE)
        self.temp_dir = Path(tempfile.mkdtemp())

    def teardown_method(self):
        import shutil

        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_prevent_etc_passwd_access(self):
        """Test that /etc/passwd access is blocked (exact Issue #109 scenario)"""
        malicious_code = """
~sorta print("harmless message")
with open("/etc/passwd", "r") as f: print(f.read())
"""

        # Create malicious program file
        malicious_file = self.temp_dir / "malicious.py"
        malicious_file.write_text(malicious_code)

        # Execute with security protection
        result = self.engine.execute_file(malicious_file)

        # Should fail due to security violation
        assert not result.success, "Execution should fail due to security violation"
        assert any(
            "passwd" in violation.lower()
            for violation in result.security_violations + result.blocked_operations
        ), "Should detect /etc/passwd access attempt"

    def test_prevent_system_file_access(self):
        """Test prevention of access to various system files"""
        system_files = [
            "/etc/passwd",
            "/etc/shadow",
            "/etc/hosts",
            "/etc/fstab",
            "/root/.bashrc",
            "/var/log/syslog",
            "/usr/bin/python",
        ]

        for file_path in system_files:
            malicious_code = f"""
try:
    with open("{file_path}", "r") as f:
        content = f.read()
        print(f"ACCESSED: {file_path}")
        print(content[:100])
except:
    print(f"FAILED to access {file_path}")
"""

            malicious_file = self.temp_dir / f"test_{file_path.replace('/', '_')}.py"
            malicious_file.write_text(malicious_code)

            result = self.engine.execute_file(malicious_file)

            # Should either fail or not show system file content
            if result.success:
                assert (
                    f"ACCESSED: {file_path}" not in result.stdout
                ), f"Should not successfully access {file_path}"
            else:
                # Failure is also acceptable for security
                assert len(result.security_violations) > 0 or len(result.blocked_operations) > 0

    def test_prevent_path_traversal_attacks(self):
        """Test prevention of path traversal attacks"""
        traversal_patterns = [
            "../etc/passwd",
            "../../etc/passwd",
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\config\\sam",
            "%2e%2e/etc/passwd",
            "..%2f..%2fetc%2fpasswd",
            "....//....//etc/passwd",
        ]

        for pattern in traversal_patterns:
            malicious_code = f"""
try:
    with open("{pattern}", "r") as f:
        content = f.read()
        print("TRAVERSAL SUCCESS: {pattern}")
        print(content[:50])
except Exception as exc:
    print("TRAVERSAL BLOCKED: {pattern} - " + str(exc))
"""

            malicious_file = self.temp_dir / f"traversal_{hash(pattern) % 1000}.py"
            malicious_file.write_text(malicious_code)

            result = self.engine.execute_file(malicious_file)

            # Should not show successful traversal
            assert (
                f"TRAVERSAL SUCCESS: {pattern}" not in result.stdout
            ), f"Path traversal should be blocked: {pattern}"

    def test_home_directory_access_restriction(self):
        """Test that access to other users' home directories is restricted"""
        if sys.platform.startswith("win"):
            restricted_paths = [
                "C:\\Users\\Administrator",
                "C:\\Users\\Guest",
                "C:\\Users\\Public",
            ]
        else:
            restricted_paths = [
                "/home/root",
                "/home/admin",
                "/home/user",
                "/root",
            ]

        for path in restricted_paths:
            malicious_code = f"""
import os
try:
    if os.path.exists("{path}"):
        file_list = os.listdir("{path}")
        print("HOME ACCESS: {path} - " + str(file_list))
    else:
        print("HOME NOT EXIST: {path}")
except Exception as exc:
    print("HOME BLOCKED: {path} - " + str(exc))
"""

            malicious_file = self.temp_dir / f"home_{hash(path) % 1000}.py"
            malicious_file.write_text(malicious_code)

            result = self.engine.execute_file(malicious_file)

            # Should not show successful home directory access
            assert (
                f"HOME ACCESS: {path}" not in result.stdout
            ), f"Home directory access should be blocked: {path}"


class TestIssue109CodeExecutionVulnerability:
    """Test prevention of arbitrary code execution (Issue #109 secondary concern)"""

    def setup_method(self):
        self.engine = SecureExecutionEngine(SecurityLevel.SAFE)
        self.temp_dir = Path(tempfile.mkdtemp())

    def teardown_method(self):
        import shutil

        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_prevent_eval_execution(self):
        """Test that eval() calls are restricted"""
        malicious_code = """
dangerous_code = "__import__('os').system('echo PWN3D')"
result = eval(dangerous_code)
print(f"EVAL SUCCESS: {result}")
"""

        malicious_file = self.temp_dir / "eval_test.py"
        malicious_file.write_text(malicious_code)

        result = self.engine.execute_file(malicious_file)

        # Should fail or not execute dangerous code
        assert "PWN3D" not in result.stdout, "eval() should not execute dangerous code"
        assert "EVAL SUCCESS" not in result.stdout, "eval() should be blocked"

    def test_prevent_exec_execution(self):
        """Test that exec() calls are restricted"""
        malicious_code = """
dangerous_code = "import os; os.system('echo PWN3D')"
exec(dangerous_code)
print("EXEC SUCCESS")
"""

        malicious_file = self.temp_dir / "exec_test.py"
        malicious_file.write_text(malicious_code)

        result = self.engine.execute_file(malicious_file)

        # Should fail or not execute dangerous code
        assert "PWN3D" not in result.stdout, "exec() should not execute dangerous code"
        assert "EXEC SUCCESS" not in result.stdout, "exec() should be blocked"

    def test_prevent_subprocess_execution(self):
        """Test that subprocess calls are restricted"""
        malicious_code = """
import subprocess
result = subprocess.run(["echo", "PWN3D"], capture_output=True, text=True)
print(f"SUBPROCESS SUCCESS: {result.stdout}")
"""

        malicious_file = self.temp_dir / "subprocess_test.py"
        malicious_file.write_text(malicious_code)

        result = self.engine.execute_file(malicious_file)

        # Should fail or not execute subprocess
        assert "PWN3D" not in result.stdout, "subprocess should not execute"
        assert "SUBPROCESS SUCCESS" not in result.stdout, "subprocess should be blocked"

    def test_prevent_os_system_execution(self):
        """Test that os.system() calls are restricted"""
        malicious_code = """
import os
result = os.system("echo PWN3D")
print(f"OS SYSTEM SUCCESS: {result}")
"""

        malicious_file = self.temp_dir / "os_system_test.py"
        malicious_file.write_text(malicious_code)

        result = self.engine.execute_file(malicious_file)

        # Should fail or not execute os.system
        assert "PWN3D" not in result.stdout, "os.system should not execute"
        assert "OS SYSTEM SUCCESS" not in result.stdout, "os.system should be blocked"


class TestFileSystemSandboxDirectly:
    """Test FileSystemSandbox component directly"""

    def setup_method(self):
        self.sandbox = FileSystemSandbox()
        self.temp_dir = Path(tempfile.mkdtemp())
        self.sandbox.set_allowed_directory(self.temp_dir)

    def teardown_method(self):
        import shutil

        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_allow_safe_file_access(self):
        """Test that safe file access within allowed directory works"""
        safe_file = self.temp_dir / "safe.txt"
        safe_file.write_text("Safe content")

        # Should allow access
        assert self.sandbox.validate_file_access(safe_file) == True

    def test_block_system_file_access(self):
        """Test that system file access is blocked"""
        system_files = [
            Path("/etc/passwd"),
            Path("/etc/shadow"),
            Path("/root/.bashrc"),
        ]

        for file_path in system_files:
            with pytest.raises(FileAccessError):
                self.sandbox.validate_file_access(file_path)

    def test_block_path_traversal(self):
        """Test that path traversal attempts are blocked"""
        traversal_attempts = [
            self.temp_dir / "../etc/passwd",
            self.temp_dir / "../../etc/passwd",
            self.temp_dir / "../../../etc/passwd",
        ]

        for path in traversal_attempts:
            with pytest.raises(FileAccessError):
                self.sandbox.validate_file_access(path)

    def test_block_outside_directory_access(self):
        """Test that access outside allowed directory is blocked"""
        outside_file = Path("/tmp/outside_file.txt")

        with pytest.raises(FileAccessError):
            self.sandbox.validate_file_access(outside_file)


class TestSecurityLevelEnforcement:
    """Test that different security levels are properly enforced"""

    def setup_method(self):
        self.temp_dir = Path(tempfile.mkdtemp())

    def teardown_method(self):
        import shutil

        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_safe_level_maximum_restriction(self):
        """Test that SAFE level provides maximum security"""
        engine = SecureExecutionEngine(SecurityLevel.SAFE)

        # Code that should be blocked in safe mode
        risky_code = """
import os
print("Trying to access system...")
try:
    files = os.listdir("/etc")
    print(f"SUCCESS: {files[:5]}")
except Exception as e:
    print(f"BLOCKED: {e}")
"""

        risky_file = self.temp_dir / "risky.py"
        risky_file.write_text(risky_code)

        result = engine.execute_file(risky_file)

        # Should be heavily restricted
        assert "SUCCESS:" not in result.stdout or not result.success
        if not result.success:
            assert len(result.security_violations) > 0 or len(result.blocked_operations) > 0

    def test_risky_level_more_permissive(self):
        """Test that RISKY level is more permissive"""
        engine = SecureExecutionEngine(SecurityLevel.RISKY)

        # Code that might be allowed in risky mode
        borderline_code = """
import json
data = {"test": "value"}
json_str = json.dumps(data)
print(f"JSON: {json_str}")
"""

        borderline_file = self.temp_dir / "borderline.py"
        borderline_file.write_text(borderline_code)

        result = engine.execute_file(borderline_file)

        # Should be more permissive
        assert result.success or len(result.security_violations) == 0

    def test_caution_level_balanced(self):
        """Test that CAUTION level provides balanced security"""
        engine = SecureExecutionEngine(SecurityLevel.CAUTION)

        # Code that should work in caution mode
        moderate_code = """
import math
import random
result = math.sqrt(random.randint(1, 100))
print(f"MATH RESULT: {result}")
"""

        moderate_file = self.temp_dir / "moderate.py"
        moderate_file.write_text(moderate_code)

        result = engine.execute_file(moderate_file)

        # Should work in caution mode
        assert result.success
        assert "MATH RESULT:" in result.stdout


class TestKindaLangFunctionalityPreservation:
    """Test that kinda-lang functionality is preserved with security"""

    def setup_method(self):
        self.engine = SecureExecutionEngine(SecurityLevel.SAFE)
        self.temp_dir = Path(tempfile.mkdtemp())

    def teardown_method(self):
        import shutil

        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_basic_kinda_constructs_work(self):
        """Test that basic kinda-lang constructs still work"""
        kinda_code = """
from kinda.personality import PersonalityContext
import random

# Simulate kinda constructs
def sorta_print(msg):
    if random.random() > 0.2:  # 80% chance
        print(msg)

def kinda_int(value):
    return value + random.randint(-1, 1)

# Basic kinda program
sorta_print("Hello, kinda world!")
x = kinda_int(42)
sorta_print(f"Kinda value: {x}")
"""

        kinda_file = self.temp_dir / "kinda_test.py"
        kinda_file.write_text(kinda_code)

        result = self.engine.execute_file(kinda_file)

        # Should work with security
        assert result.success, f"Kinda code should work: {result.stderr}"
        # Output may vary due to probabilistic nature, but should not error

    def test_personality_system_works(self):
        """Test that personality system works with security"""
        personality_code = """
from kinda.personality import PersonalityContext

# Set up personality
PersonalityContext.set_mood("playful")
PersonalityContext.set_chaos_level(5)

print("Personality system working!")
"""

        personality_file = self.temp_dir / "personality_test.py"
        personality_file.write_text(personality_code)

        result = self.engine.execute_file(personality_file)

        # Should work with security
        assert result.success
        assert "Personality system working!" in result.stdout


class TestSecurityIntegrationWithCLI:
    """Test security integration with CLI commands"""

    def test_security_level_parameter_exists(self):
        """Test that CLI accepts security level parameters"""
        # This is more of a smoke test to ensure CLI integration
        from kinda.cli import main

        # Test that help includes security options
        try:
            main(["run", "--help"])
        except SystemExit:
            pass  # Expected for --help

        try:
            main(["inject", "run", "--help"])
        except SystemExit:
            pass  # Expected for --help


class TestIssue109RegressionPrevention:
    """Specific regression tests for Issue #109 scenarios"""

    def setup_method(self):
        self.engine = SecureExecutionEngine(SecurityLevel.SAFE)
        self.temp_dir = Path(tempfile.mkdtemp())

    def teardown_method(self):
        import shutil

        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_exact_issue_109_poc(self):
        """Test exact Proof of Concept from Issue #109"""
        # Exact code from Issue #109
        poc_code = """
~sorta print("harmless message")
with open("/etc/passwd", "r") as f: print(f.read())
"""

        poc_file = self.temp_dir / "poc.knda"
        poc_file.write_text(poc_code)

        # This would be processed by transformer first, but we test the execution part
        python_poc = """
import random

def sorta_print(msg):
    if random.random() > 0.2:
        print(msg)

# Malicious part
sorta_print("harmless message")
with open("/etc/passwd", "r") as f: print(f.read())
"""

        python_file = self.temp_dir / "poc.py"
        python_file.write_text(python_poc)

        result = self.engine.execute_file(python_file)

        # Should be blocked
        assert (
            not result.success or "root:x:" not in result.stdout
        ), "Issue #109 PoC should be blocked"
        assert any(
            "passwd" in str(item).lower()
            for item in result.security_violations + result.blocked_operations
        ), "Should detect passwd access attempt"

    def test_variations_of_issue_109(self):
        """Test variations and obfuscations of Issue #109"""
        variations = [
            # Different file paths
            'with open("/etc/shadow", "r") as f: print(f.read()[:100])',
            'with open("/proc/version", "r") as f: print(f.read())',
            # Path obfuscation
            'path = "/etc/" + "passwd"; with open(path, "r") as f: print(f.read()[:50])',
            'import os; path = os.path.join("/etc", "passwd"); with open(path) as f: print(f.read()[:50])',
            # Different access methods
            'import pathlib; print(pathlib.Path("/etc/passwd").read_text()[:50])',
            'from pathlib import Path; print(Path("/etc/passwd").read_text()[:50])',
        ]

        for i, code in enumerate(variations):
            variation_file = self.temp_dir / f"variation_{i}.py"
            variation_file.write_text(code)

            result = self.engine.execute_file(variation_file)

            # Should be blocked or show no sensitive content
            assert not result.success or not any(
                sensitive in result.stdout.lower()
                for sensitive in ["root:x:", "daemon:x:", "/bin/bash"]
            ), f"Variation {i} should be blocked: {code}"


if __name__ == "__main__":
    print("Running Issue #109 Security Vulnerability Tests...")

    # Quick smoke test
    engine = SecureExecutionEngine(SecurityLevel.SAFE)
    temp_dir = Path(tempfile.mkdtemp())

    try:
        # Test basic security
        malicious_code = 'with open("/etc/passwd", "r") as f: print("ACCESSED PASSWD")'
        test_file = temp_dir / "smoke_test.py"
        test_file.write_text(malicious_code)

        result = engine.execute_file(test_file)

        if "ACCESSED PASSWD" in result.stdout:
            print("❌ SECURITY FAILURE: /etc/passwd was accessed!")
        else:
            print("✅ SECURITY SUCCESS: /etc/passwd access blocked")

        print(f"   Success: {result.success}")
        print(f"   Security violations: {len(result.security_violations)}")
        print(f"   Blocked operations: {len(result.blocked_operations)}")

    finally:
        import shutil

        shutil.rmtree(temp_dir, ignore_errors=True)

    print("Issue #109 security tests ready for full pytest execution!")
