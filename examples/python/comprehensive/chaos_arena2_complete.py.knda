# -----------------------------------------------------------
# Chaos Arena 2 Complete - ALL Constructs Multi-Agent Simulation
# -----------------------------------------------------------
# Enhanced sophisticated chaos simulation with ALL 6 kinda constructs:
# 1. ~kinda int x = value      (fuzzy integers with ±1 noise)
# 2. ~sorta print(...)         (probabilistic printing 80/20)
# 3. x ~= value               (fuzzy reassignment with ±1 noise)  
# 4. ~sometimes (cond) {}     (probabilistic conditionals 50%)
# 5. ~maybe (cond) {}         (probabilistic conditionals 60%)
# 6. value~ish                (fuzzy values with ±2 variance)
# 7. value1 ~ish value2       (fuzzy comparisons with ±2 tolerance)
# 8. ~kinda binary            (ternary logic: 1, -1, 0)

import time, random, math, statistics
from collections import defaultdict

# === CONFIGURATION WITH KINDA TRANSFORMS ===
~kinda int simulation_time = 8
~kinda int agent_count = 3
~kinda int steps_per_trial = 80
~kinda int trials_per_batch = 60

~sorta print("=== CHAOS ARENA 2 COMPLETE - ALL CONSTRUCTS EDITION ===")
~sorta print("Simulation time:", simulation_time, "seconds")
~sorta print("Agents:", agent_count)

# Enhanced agent definitions with fuzzy parameters
AGENTS = [
    {"name": "chaos_walker", "aggression": 0.2, "boost_power": 3, "mood_variance": 0.3},
    {"name": "drift_master", "aggression": 0.1, "boost_power": 2, "mood_variance": 0.1}, 
    {"name": "wild_jumper", "aggression": 0.4, "boost_power": 5, "mood_variance": 0.5},
    {"name": "steady_eddie", "aggression": 0.05, "boost_power": 1, "mood_variance": 0.05},
]

def chaos_step():
    # Enhanced chaotic step with ish fuzzy values
    base_step = 1 if random.random() < 0.5 else -1
    return base_step ~ish  # Add fuzzy variance to chaos steps

def run_agent_trial(agent, steps):
    # Initialize agent with fuzzy starting values
    ~kinda int position = 0
    ~kinda int energy = 50
    ~kinda int chaos_level = 1
    
    # NEW: Agent mood system using kinda binary
    ~kinda binary agent_mood ~ probabilities(0.4, 0.3, 0.3)
    
    # Track enhanced metrics
    aggression_triggers = 0
    boost_applications = 0
    total_boost_magnitude = 0
    energy_restorations = 0
    extreme_events_experienced = 0
    position_dampings = 0
    mood_shifts = 0
    fuzzy_comparisons_triggered = 0
    maybe_events = 0
    sometimes_events = 0
    step_positions = []
    step_energies = []
    step_moods = []
    
    ~maybe (agent_mood != 0) {
        ~sorta print("Agent", agent["name"], "starting with mood:", agent_mood)
    }
    
    for step in range(steps):
        # Basic movement with enhanced fuzziness
        movement = chaos_step()  # Already fuzzy from chaos_step()
        position ~= position + movement
        
        # Energy management with ish comparisons
        energy ~= energy - 1
        
        # NEW: Mood-influenced behavior
        mood_influence = agent_mood * agent["mood_variance"]
        
        ~maybe (mood_influence ~ish 0.2) {
            ~sorta print("Positive mood boost for", agent["name"])
            energy ~= 3  # Mood boost
            maybe_events += 1
        }
        
        negative_threshold = -0.2
        ~maybe (mood_influence ~ish negative_threshold) {
            # Negative mood impact
            energy ~= -2
            maybe_events += 1
        }
        
        # Agent-specific chaos events enhanced with new constructs
        chaos_trigger = random.random() < agent["aggression"]
        
        ~sometimes (chaos_trigger) {
            aggression_triggers += 1
            sometimes_events += 1
            
            # Enhanced boost calculation with fuzzy logic
            base_boost = agent["boost_power"]
            ~kinda int fuzzy_boost = base_boost * chaos_step()
            
            # Use ish comparison for boost effectiveness
            boost_magnitude = abs(fuzzy_boost)
            boost_power = agent["boost_power"]
            ~maybe (boost_magnitude ~ish boost_power) {
                boost_applications += 1
                total_boost_magnitude += abs(fuzzy_boost)
                position ~= position + fuzzy_boost
                energy ~= energy + 3
                chaos_level ~= chaos_level + 1
                
                ~sorta print("Effective boost for", agent["name"], "magnitude:", fuzzy_boost)
            }
        }
        
        # Enhanced energy restoration with fuzzy thresholds
        low_energy_threshold = 10~ish
        ~maybe (energy ~ish low_energy_threshold) {
            energy_restorations += 1
            restore_amount = 25~ish  # Fuzzy energy restore
            energy ~= restore_amount
            ~sorta print("Energy restoration for", agent["name"], "amount:", restore_amount)
        }
        
        # Enhanced extreme events with kinda binary decisions
        extreme_event_chance = random.random() < 0.01
        ~sometimes (extreme_event_chance) {
            extreme_events_experienced += 1
            
            # Use kinda binary for extreme event type
            ~kinda binary extreme_type ~ probabilities(0.5, 0.3, 0.2)
            
            ~maybe (extreme_type == 1) {
                # Positive extreme event
                extreme_jump_base = random.randint(20, 40)
                extreme_jump = extreme_jump_base~ish
                position ~= position + extreme_jump
                chaos_level ~= chaos_level + 2
                ~sorta print("POSITIVE EXTREME:", agent["name"], "jump:", extreme_jump)
            }
            
            ~maybe (extreme_type == -1) {
                # Negative extreme event  
                extreme_fall_base = random.randint(15, 35)
                extreme_fall = extreme_fall_base~ish
                position ~= position - extreme_fall
                energy ~= -5
                ~sorta print("NEGATIVE EXTREME:", agent["name"], "fall:", extreme_fall)
            }
            
            ~maybe (extreme_type == 0) {
                # Neutral/weird extreme event
                chaos_level ~= chaos_level + 3
                ~sorta print("CHAOTIC EXTREME:", agent["name"], "pure chaos!")
            }
        }
        
        # Position limits with enhanced fuzzy boundaries
        position_limit = 200~ish
        position_magnitude = abs(position)
        ~maybe (position_magnitude ~ish position_limit) {
            position_dampings += 1
            damping_factor_base = random.uniform(0.3, 0.7)
            damping_factor = damping_factor_base~ish
            position ~= position * damping_factor
            fuzzy_comparisons_triggered += 1
            ~sorta print("Position damping for", agent["name"], "factor:", damping_factor)
        }
        
        # Dynamic mood shifts
        mood_shift_chance = random.random() < 0.05
        ~sometimes (mood_shift_chance) {
            old_mood = agent_mood
            # Generate new mood randomly
            mood_rand = random.random()
            if mood_rand < 0.4:
                agent_mood = 1
            elif mood_rand < 0.7:
                agent_mood = -1
            else:
                agent_mood = 0
            
            ~maybe (agent_mood != old_mood) {
                mood_shifts += 1
                ~sorta print("Mood shift for", agent["name"], "from", old_mood, "to", agent_mood)
            }
        }
        
        # Track step-by-step data for enhanced behavioral analysis
        step_positions.append(position)
        step_energies.append(energy)
        step_moods.append(agent_mood)
    
    # Enhanced behavioral metrics calculation
    observed_aggression_rate = aggression_triggers / steps
    avg_boost_magnitude = total_boost_magnitude / max(boost_applications, 1)
    position_variance = statistics.pvariance(step_positions) if len(step_positions) > 1 else 0
    energy_stability = statistics.pstdev(step_energies) if len(step_energies) > 1 else 0
    mood_stability = statistics.pstdev(step_moods) if len(step_moods) > 1 else 0
    
    # NEW: Fuzzy construct usage metrics
    maybe_effectiveness = maybe_events / steps
    sometimes_effectiveness = sometimes_events / steps
    fuzzy_comparison_rate = fuzzy_comparisons_triggered / steps
    
    return {
        "position": position, 
        "energy": energy, 
        "chaos": chaos_level,
        "final_mood": agent_mood,
        # Original metrics
        "observed_aggression_rate": observed_aggression_rate,
        "expected_aggression_rate": agent["aggression"],
        "aggression_triggers": aggression_triggers,
        "boost_applications": boost_applications,
        "avg_boost_magnitude": avg_boost_magnitude,
        "expected_boost_power": agent["boost_power"],
        "energy_restorations": energy_restorations,
        "extreme_events": extreme_events_experienced,
        "position_dampings": position_dampings,
        "position_variance": position_variance,
        "energy_stability": energy_stability,
        "behavioral_consistency": abs(observed_aggression_rate - agent["aggression"]),
        # NEW: Enhanced fuzzy metrics
        "mood_shifts": mood_shifts,
        "mood_stability": mood_stability,
        "maybe_effectiveness": maybe_effectiveness,
        "sometimes_effectiveness": sometimes_effectiveness,
        "fuzzy_comparison_rate": fuzzy_comparison_rate,
        "maybe_events": maybe_events,
        "sometimes_events": sometimes_events
    }

def run_batch_simulation(agent, steps, trials):
    batch_results = []
    
    ~sorta print("Running batch for", agent["name"], "with", trials, "trials")
    
    for trial in range(trials):
        result = run_agent_trial(agent, steps)
        batch_results.append(result)
    
    return batch_results

def analyze_results(agent_name, results):
    if not results:
        return
    
    # Basic metrics
    positions = [r["position"] for r in results]
    energies = [r["energy"] for r in results]
    chaos_levels = [r["chaos"] for r in results]
    final_moods = [r["final_mood"] for r in results]
    
    pos_mean = statistics.fmean(positions)
    pos_stdev = statistics.pstdev(positions) if len(positions) > 1 else 0
    energy_mean = statistics.fmean(energies)
    chaos_mean = statistics.fmean(chaos_levels)
    mood_mean = statistics.fmean(final_moods)
    
    # Enhanced fuzzy construct metrics
    maybe_effectiveness = statistics.fmean([r["maybe_effectiveness"] for r in results])
    sometimes_effectiveness = statistics.fmean([r["sometimes_effectiveness"] for r in results])
    fuzzy_comparison_rates = statistics.fmean([r["fuzzy_comparison_rate"] for r in results])
    mood_stabilities = statistics.fmean([r["mood_stability"] for r in results])
    
    # Original personality metrics
    observed_aggression_rates = [r["observed_aggression_rate"] for r in results]
    expected_aggression_rates = [r["expected_aggression_rate"] for r in results]
    avg_boost_magnitudes = [r["avg_boost_magnitude"] for r in results]
    behavioral_consistencies = [r["behavioral_consistency"] for r in results]
    
    aggression_accuracy = 1 - statistics.fmean(behavioral_consistencies)
    boost_effectiveness = statistics.fmean(avg_boost_magnitudes)
    
    ~sorta print(f"\n{agent_name} COMPLETE Analysis:");
    ~sorta print(f"  Position: mean={pos_mean:.1f} stdev={pos_stdev:.1f}");
    ~sorta print(f"  Energy: mean={energy_mean:.1f} | Chaos: mean={chaos_mean:.1f}");
    ~sorta print(f"  Final Mood: mean={mood_mean:.2f}");
    
    ~sorta print(f"\n{agent_name} Fuzzy Construct Usage:");
    ~sorta print(f"  Maybe Effectiveness: {maybe_effectiveness:.3f}");
    ~sorta print(f"  Sometimes Effectiveness: {sometimes_effectiveness:.3f}");
    ~sorta print(f"  Fuzzy Comparison Rate: {fuzzy_comparison_rates:.3f}");
    ~sorta print(f"  Mood Stability: {1-mood_stabilities:.3f}");
    
    # Enhanced personality validation
    expected_aggression = expected_aggression_rates[0]
    personality_score = (aggression_accuracy + (boost_effectiveness / 10) + 
                        maybe_effectiveness + sometimes_effectiveness) / 4
    
    ~sorta print(f"\n{agent_name} Enhanced Personality Score: {personality_score:.3f}");
    
    return {
        "pos_mean": pos_mean,
        "pos_stdev": pos_stdev,
        "energy_mean": energy_mean,
        "chaos_mean": chaos_mean,
        "mood_mean": mood_mean,
        "aggression_accuracy": aggression_accuracy,
        "boost_effectiveness": boost_effectiveness,
        "maybe_effectiveness": maybe_effectiveness,
        "sometimes_effectiveness": sometimes_effectiveness,
        "fuzzy_comparison_rate": fuzzy_comparison_rates,
        "mood_stability": mood_stabilities,
        "personality_score": personality_score,
        "expected_aggression": expected_aggression
    }

def main():
    start_time = time.time()
    end_time = start_time + simulation_time
    
    # Initialize enhanced data collection
    all_agent_data = {}
    for agent in AGENTS[:agent_count]:
        all_agent_data[agent["name"]] = []
    
    ~kinda int batch_number = 0
    ~kinda int total_trials_run = 0
    
    ~sorta print("Beginning COMPLETE chaos simulation with ALL constructs...")
    
    # Main enhanced simulation loop
    while time.time() < end_time:
        batch_number ~= batch_number + 1
        
        ~maybe (batch_number ~ish 1) {
            ~sorta print("🎪 First batch - initializing complete chaos!")
        }
        
        ~sorta print("Running enhanced batch", batch_number)
        
        # Run simulation for each agent with enhanced tracking
        for agent in AGENTS[:agent_count]:
            current_trials = trials_per_batch~ish  # Fuzzy trial count
            
            batch_results = run_batch_simulation(agent, steps_per_trial, current_trials)
            all_agent_data[agent["name"]].extend(batch_results)
            
            total_trials_run ~= total_trials_run + current_trials
            
            # Enhanced batch analysis
            positions = [r["position"] for r in batch_results]
            maybe_events = [r["maybe_events"] for r in batch_results]
            sometimes_events = [r["sometimes_events"] for r in batch_results]
            
            batch_mean = statistics.fmean(positions)
            batch_maybe_rate = statistics.fmean(maybe_events) / steps_per_trial
            batch_sometimes_rate = statistics.fmean(sometimes_events) / steps_per_trial
            
            # Real-time fuzzy construct effectiveness tracking
            ~maybe (batch_maybe_rate ~ish 0.1) {
                ~sorta print("HIGH MAYBE ACTIVITY:", agent["name"], "rate:", f"{batch_maybe_rate:.3f}")
            }
            
            ~maybe (batch_sometimes_rate ~ish 0.08) {
                ~sorta print("HIGH SOMETIMES ACTIVITY:", agent["name"], "rate:", f"{batch_sometimes_rate:.3f}")
            }
            
            # Enhanced probabilistic progress reporting
            ~kinda binary should_report ~ probabilities(0.4, 0.2, 0.4)
            ~maybe (should_report != 0) {
                ~sorta print("Agent", agent["name"], "batch mean:", f"{batch_mean:.1f}", "maybe_rate:", f"{batch_maybe_rate:.3f}", "sometimes_rate:", f"{batch_sometimes_rate:.3f}")
            }
    
    # === ENHANCED FINAL ANALYSIS ===
    ~sorta print("\n" + "="*70);
    ~sorta print("COMPLETE CHAOS ARENA ANALYSIS - ALL CONSTRUCTS");
    ~sorta print("="*70);
    ~sorta print("Total batches:", batch_number);
    ~sorta print("Total trials:", total_trials_run);
    
    final_stats = {}
    
    for agent in AGENTS[:agent_count]:
        name = agent["name"]
        results = all_agent_data[name]
        
        if results:
            stats = analyze_results(name, results)
            final_stats[name] = stats
    
    # Enhanced cross-agent analysis
    ~maybe (len(final_stats) >= 2) {
        ~sorta print("\n" + "="*70);
        ~sorta print("COMPLETE CROSS-AGENT ANALYSIS");
        ~sorta print("="*70);
        
        # Fuzzy construct effectiveness ranking
        agent_names = list(final_stats.keys())
        
        construct_rankings = []
        for name in agent_names:
            stats = final_stats[name]
            overall_construct_score = (stats["maybe_effectiveness"] + 
                                     stats["sometimes_effectiveness"] + 
                                     stats["fuzzy_comparison_rate"] + 
                                     (1 - stats["mood_stability"])) / 4
            construct_rankings.append((name, overall_construct_score))
        
        construct_rankings.sort(key=lambda x: x[1], reverse=True)
        
        ~sorta print("\n🏆 Fuzzy Construct Master Ranking:");
        for i, (name, score) in enumerate(construct_rankings):
            ~sorta print(f"  {i+1}. {name}: {score:.3f} (construct mastery)");
        
        # Enhanced personality validation summary
        total_personality_score = 0
        for name in agent_names:
            stats = final_stats[name]
            total_personality_score += stats["personality_score"]
        
        overall_simulation_quality = total_personality_score / len(agent_names)
        
        ~sorta print(f"\n🎯 Overall COMPLETE Simulation Quality: {overall_simulation_quality:.3f}");
        
        quality_assessment = "MASTERFUL" if overall_simulation_quality > 0.7 else \
                           "EXCELLENT" if overall_simulation_quality > 0.5 else \
                           "GOOD" if overall_simulation_quality > 0.3 else \
                           "CHAOTIC"
        
        ~sorta print(f"🌟 Complete Chaos Assessment: {quality_assessment}");
    }
    
    ~sorta print("\n=== COMPLETE SIMULATION FINISHED ===");
    ~sorta print("🎪 All constructs have been tested in glorious chaos!");
    ~sorta print("🎭 Reality has been thoroughly perturbed with COMPLETE fuzzy logic!");

# Demonstrate ALL constructs at top level
~sometimes (True) {
    ~sorta print("🎲 Complete chaos initialization: ALL CONSTRUCTS READY");
}

~maybe (True) {
    initialization_success = 42~ish
    ~sorta print("🌟 Initialization fuzziness:", initialization_success);
}

~kinda binary simulation_confidence ~ probabilities(0.7, 0.2, 0.1)
~maybe (simulation_confidence == 1) {
    ~sorta print("🎯 High confidence in complete simulation!")
}

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"Complete chaos overflow detected: {e}")

# Enhanced post-simulation chaos check with all constructs
~sometimes (True) {
    final_chaos_level = 100~ish
    ~maybe (final_chaos_level ~ish 100) {
        ~sorta print("🎪 Post-simulation chaos level: MAXIMUM COMPLETE!")
    }
}