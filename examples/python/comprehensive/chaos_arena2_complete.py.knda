# -----------------------------------------------------------
# Chaos Arena 2 Complete - Simplified Working Version
# -----------------------------------------------------------
# Demonstrates core kinda constructs without transformer bugs:
# 1. ~kinda int x = value      (fuzzy integers)
# 2. ~sorta print(...)         (probabilistic printing)
# 3. x ~= value               (fuzzy reassignment)
# 4. ~sometimes (cond) {}     (probabilistic conditionals)
# 5. ~maybe (cond) {}         (probabilistic conditionals)
# 6. ~kinda binary            (ternary logic)

import time, random, math, statistics
from collections import defaultdict

# === CONFIGURATION WITH KINDA TRANSFORMS ===
~kinda int simulation_time = 3;
~kinda int agent_count = 2;
~kinda int steps_per_trial = 20;
~kinda int trials_per_batch = 10;

~sorta print("=== CHAOS ARENA 2 COMPLETE - SIMPLIFIED EDITION ===");
~sorta print("Simulation time:", simulation_time, "seconds");
~sorta print("Agents:", agent_count);

# Simple agent definitions
AGENTS = [
    {"name": "chaos_walker", "aggression": 0.3, "boost_power": 3},
    {"name": "wild_jumper", "aggression": 0.4, "boost_power": 5},
]

def chaos_step():
    # Simple chaotic step
    base_step = 1 if random.random() < 0.5 else -1
    return base_step * random.uniform(0.8, 1.2)  # Add fuzzy variance

def run_agent_trial(agent, steps):
    # Initialize agent with fuzzy starting values
    ~kinda int position = 0
    ~kinda int energy = 50
    ~kinda int chaos_level = 1
    
    # Agent mood system using kinda binary
    ~kinda binary agent_mood
    
    # Track metrics
    aggression_triggers = 0
    boost_applications = 0
    energy_restorations = 0
    extreme_events_experienced = 0
    maybe_events = 0
    sometimes_events = 0
    
    ~maybe (agent_mood != 0) {
        ~sorta print("Agent", agent["name"], "starting with mood:", agent_mood);
    }
    
    for step in range(steps):
        # Basic movement
        movement = chaos_step()
        position ~= position + movement;
        
        # Energy management
        energy ~= energy - 1;
        
        # Mood-influenced behavior
        mood_influence = agent_mood * 0.1
        
        ~maybe (mood_influence > 0.05) {
            ~sorta print("Positive mood boost for", agent["name"]);
            energy ~= 3
            maybe_events += 1
        }
        
        # Agent-specific chaos events
        chaos_trigger = random.random() < agent["aggression"]
        
        ~sometimes (chaos_trigger) {
            aggression_triggers += 1
            sometimes_events += 1
            
            # Simple boost calculation
            base_boost = agent["boost_power"]
            ~kinda int fuzzy_boost = base_boost * chaos_step();
            
            ~maybe (abs(fuzzy_boost) >= agent["boost_power"]) {
                boost_applications += 1
                position ~= position + fuzzy_boost;
                energy ~= energy + 3;
                chaos_level ~= chaos_level + 1;
                
                ~sorta print("Boost for", agent["name"], "magnitude:", fuzzy_boost);
            }
        }
        
        # Energy restoration
        low_energy_threshold = random.randint(8, 12)
        ~maybe (energy <= low_energy_threshold + 2) {
            energy_restorations += 1
            restore_amount = random.randint(23, 27)
            energy ~= restore_amount;
            ~sorta print("Energy restoration for", agent["name"], "amount:", restore_amount);
        }
        
        # Extreme events
        extreme_event_chance = random.random() < 0.02
        ~sometimes (extreme_event_chance) {
            extreme_events_experienced += 1
            
            # Use kinda binary for extreme event type
            ~kinda binary extreme_type
            
            ~maybe (extreme_type == 1) {
                # Positive extreme event
                extreme_jump = random.randint(18, 22)
                position ~= position + extreme_jump;
                chaos_level ~= chaos_level + 2;
                ~sorta print("POSITIVE EXTREME:", agent["name"], "jump:", extreme_jump);
            }
            
            ~maybe (extreme_type == -1) {
                # Negative extreme event  
                extreme_fall = random.randint(13, 17)
                position ~= position - extreme_fall;
                energy ~= -5
                ~sorta print("NEGATIVE EXTREME:", agent["name"], "fall:", extreme_fall);
            }
            
            ~maybe (extreme_type == 0) {
                # Neutral extreme event
                chaos_level ~= chaos_level + 3;
                ~sorta print("CHAOTIC EXTREME:", agent["name"], "pure chaos!");
            }
        }
        
        # Position limits
        position_limit = random.randint(195, 205)
        ~maybe (abs(position) >= position_limit - 10) {
            damping_factor = random.uniform(0.4, 0.6)
            position ~= position * damping_factor;
            ~sorta print("Position damping for", agent["name"], "factor:", damping_factor);
        }
    
    return {
        "position": position, 
        "energy": energy, 
        "chaos": chaos_level,
        "final_mood": agent_mood,
        "aggression_triggers": aggression_triggers,
        "boost_applications": boost_applications,
        "energy_restorations": energy_restorations,
        "extreme_events": extreme_events_experienced,
        "maybe_events": maybe_events,
        "sometimes_events": sometimes_events
    }

def run_batch_simulation(agent, steps, trials):
    batch_results = []
    
    ~sorta print("Running batch for", agent["name"], "with", trials, "trials");
    
    for trial in range(trials):
        result = run_agent_trial(agent, steps)
        batch_results.append(result)
    
    return batch_results

def analyze_results(agent_name, results):
    if not results:
        return
    
    # Basic metrics
    positions = [r["position"] for r in results]
    energies = [r["energy"] for r in results]
    chaos_levels = [r["chaos"] for r in results]
    final_moods = [r["final_mood"] for r in results]
    
    pos_mean = statistics.fmean(positions)
    energy_mean = statistics.fmean(energies)
    chaos_mean = statistics.fmean(chaos_levels)
    mood_mean = statistics.fmean(final_moods)
    
    ~sorta print(f"\n{agent_name} Analysis:");
    ~sorta print(f"  Position: {pos_mean:.1f} | Energy: {energy_mean:.1f}");
    ~sorta print(f"  Chaos: {chaos_mean:.1f} | Mood: {mood_mean:.2f}");
    
    return {
        "pos_mean": pos_mean,
        "energy_mean": energy_mean,
        "chaos_mean": chaos_mean,
        "mood_mean": mood_mean
    }

def main():
    start_time = time.time()
    end_time = start_time + simulation_time
    
    # Initialize data collection
    all_agent_data = {}
    for agent in AGENTS[:agent_count]:
        all_agent_data[agent["name"]] = []
    
    ~kinda int batch_number = 0;
    ~kinda int total_trials_run = 0;
    
    ~sorta print("Beginning simplified chaos simulation...");
    
    # Main simulation loop
    while time.time() < end_time:
        batch_number ~= batch_number + 1;
        
        ~maybe (batch_number <= 2) {
            ~sorta print("First batch - initializing chaos!");
        }
        
        ~sorta print("Running batch", batch_number);
        
        # Run simulation for each agent
        for agent in AGENTS[:agent_count]:
            current_trials = trials_per_batch + random.randint(-2, 2)
            
            batch_results = run_batch_simulation(agent, steps_per_trial, current_trials)
            all_agent_data[agent["name"]].extend(batch_results)
            
            total_trials_run ~= total_trials_run + current_trials;
            
            # Real-time tracking
            positions = [r["position"] for r in batch_results]
            maybe_events = [r["maybe_events"] for r in batch_results]
            
            batch_mean = statistics.fmean(positions)
            batch_maybe_rate = statistics.fmean(maybe_events) / steps_per_trial
            
            ~maybe (batch_maybe_rate > 0.08) {
                ~sorta print("HIGH MAYBE ACTIVITY:", agent["name"]);
            }
            
            # Progress reporting
            ~kinda binary should_report
            ~maybe (should_report != 0) {
                ~sorta print("Agent", agent["name"], "batch mean:", f"{batch_mean:.1f}");
            }
    
    # Final Analysis
    ~sorta print("\n" + "="*50);
    ~sorta print("CHAOS ARENA ANALYSIS");
    ~sorta print("="*50);
    ~sorta print("Total batches:", batch_number);
    ~sorta print("Total trials:", total_trials_run);
    
    final_stats = {}
    
    for agent in AGENTS[:agent_count]:
        name = agent["name"]
        results = all_agent_data[name]
        
        if results:
            stats = analyze_results(name, results)
            final_stats[name] = stats
    
    # Cross-agent analysis
    ~maybe (len(final_stats) >= 2) {
        ~sorta print("\n" + "="*50);
        ~sorta print("CROSS-AGENT ANALYSIS");
        ~sorta print("="*50);
        
        agent_names = list(final_stats.keys())
        
        overall_quality = sum(stats["chaos_mean"] for stats in final_stats.values()) / len(final_stats)
        
        ~sorta print(f"Overall Simulation Quality: {overall_quality:.3f}");
        
        quality_assessment = "EXCELLENT" if overall_quality > 3.0 else \
                           "GOOD" if overall_quality > 2.0 else \
                           "CHAOTIC"
        
        ~sorta print(f"Assessment: {quality_assessment}");
    }
    
    ~sorta print("\n=== SIMULATION FINISHED ===");
    ~sorta print("Chaos achieved successfully!");

# Demonstrate constructs at top level
~sometimes (True) {
    ~sorta print("Chaos initialization: READY");
}

~maybe (True) {
    initialization_success = random.randint(40, 44)
    ~sorta print("Initialization fuzziness:", initialization_success);
}

~kinda binary simulation_confidence
~maybe (simulation_confidence == 1) {
    ~sorta print("High confidence in simulation!");
}

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"Chaos overflow detected: {e}")

# Post-simulation chaos check
~sometimes (True) {
    final_chaos_level = random.randint(98, 102)
    ~maybe (final_chaos_level > 95) {
        ~sorta print("Post-simulation chaos level: MAXIMUM!");
    }
}